

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Source: table/Table.vue | Tui JSDoc Template</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/bootstrap.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-jsdoc.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/tui-doc.css">

    
</head>
<body>
<nav class="lnb" id="lnb">
    <div class="logo" style="width: 150px; height: 13px">
        
            <a href="https://github.com/nhnent/tui.jsdoc-template" rel="noopener noreferrer" target="_blank">
                <img src="http://nhnent.github.io/tui.component.tree/latest/styles/logo.png" width="100%" height="100%">
            </a>
        
    </div>
    <div class="title">
        <h1><a href="index.html" class="link">Tui JSDoc Template</a></h1>
        
    </div>
    <div class="search-container" id="search-container">
        <input type="text" placeholder="Search">
        <ul></ul>
    </div>
    
    
</nav>
<div id="resizer"></div>

<div class="main" id="main">
    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>&lt;template>
  &lt;div 
    :class="{ 'is-loading': loading }" 
    class="b-table">
    &lt;b-table-mobile-sort
      v-if="mobileCards &amp;&amp; hasSortablenewColumns"
      :current-sort-column="currentSortColumn"
      :is-asc="isAsc"
      :columns="newColumns"
      @sort="(column) => sort(column)"
    />

    &lt;div class="table-wrapper">
      &lt;table
        :class="tableClasses"
        :tabindex="!focusable ? false : 0"
        class="table"
        @keydown.prevent.up="pressedArrow(-1)"
        @keydown.prevent.down="pressedArrow(1)">
        &lt;thead v-if="newColumns.length">
          &lt;tr>
            &lt;th 
              v-if="detailed" 
              width="40px"/>
            &lt;th 
              v-if="checkable" 
              class="checkbox-cell">
              &lt;b-checkbox
                :value="isAllChecked"
                :disabled="isAllUncheckable"
                @change.native="checkAll"/>
            &lt;/th>
            &lt;th
              v-for="(column, index) in newColumns"
              v-if="column.visible || column.visible === undefined"
              :key="index"
              :class="{
                'is-current-sort': currentSortColumn === column,
                'is-sortable': column.sortable
              }"
              :style="{ width: column.width + 'px' }"
              @click.stop="sort(column)">
              &lt;div
                :class="{
                  'is-numeric': column.numeric,
                  'is-centered': column.centered
                }"
                class="th-wrap">
                &lt;slot
                  v-if="$scopedSlots.header"
                  :column="column"
                  :index="index"
                  name="header"
                />
                &lt;template v-else>{{ column.label }}&lt;/template>

                &lt;b-icon
                  v-show="currentSortColumn === column"
                  :icon-pack="iconPack"
                  :class="{ 'is-desc': !isAsc }"
                  icon="arrow-up"
                  both
                  size="is-small"/>
              &lt;/div>
            &lt;/th>
          &lt;/tr>
        &lt;/thead>
        &lt;tbody v-if="visibleData.length">
          &lt;template v-for="(row, index) in visibleData">
            &lt;tr
              :key="index"
              :class="[rowClass(row, index), {
                'is-selected': row === selected,
                'is-checked': isRowChecked(row)
              }]"
              @click="selectRow(row)"
              @dblclick="$emit('dblclick', row)">

              &lt;td
                v-if="detailed"
                class="chevron-cell"
              >
                &lt;a
                  v-if="hasDetailedVisible(row)"
                  role="button"
                  @click.stop="toggleDetails(row)">
                  &lt;b-icon
                    :icon-pack="iconPack"
                    :class="{'is-expanded': isVisibleDetailRow(row)}"
                    icon="chevron-right"
                    both/>
                &lt;/a>
              &lt;/td>

              &lt;td 
                v-if="checkable" 
                class="checkbox-cell">
                &lt;b-checkbox
                  :disabled="!isRowCheckable(row)"
                  :value="isRowChecked(row)"
                  @change.native="checkRow(row)"
                />
              &lt;/td>

              &lt;slot
                v-if="$scopedSlots.default"
                :row="row"
                :index="index"
              />
              &lt;template v-else>
                &lt;BTableColumn
                  v-for="column in newColumns"
                  v-bind="column"
                  :key="column.field"
                  internal>
                  &lt;span
                    v-if="column.renderHtml"
                    v-html="getValueByPath(row, column.field)"
                  />
                  &lt;template v-else>
                    {{ getValueByPath(row, column.field) }}
                  &lt;/template>
                &lt;/BTableColumn>
              &lt;/template>
            &lt;/tr>

            &lt;!-- Do not add `key` here (breaks details) -->
            &lt;!-- eslint-disable-next-line -->
                        &lt;tr
              v-if="detailed &amp;&amp; isVisibleDetailRow(row)"
              class="detail">
              &lt;td :colspan="columnCount">
                &lt;div class="detail-container">
                  &lt;slot
                    :row="row"
                    :index="index"
                    name="detail"/>
                &lt;/div>
              &lt;/td>
            &lt;/tr>
          &lt;/template>
        &lt;/tbody>
        &lt;tbody v-else>
          &lt;tr class="is-empty">
            &lt;td :colspan="columnCount">
              &lt;slot name="empty"/>
            &lt;/td>
          &lt;/tr>
        &lt;/tbody>
        &lt;tfoot v-if="$slots.footer !== undefined">
          &lt;tr class="table-footer">
            &lt;slot 
              v-if="hasCustomFooterSlot()" 
              name="footer"/>
            &lt;th 
              v-else 
              :colspan="columnCount">
              &lt;slot name="footer"/>
            &lt;/th>
          &lt;/tr>
        &lt;/tfoot>
      &lt;/table>
    &lt;/div>

    &lt;div 
      v-if="(checkable &amp;&amp; hasBottomLeftSlot()) || paginated" 
      class="level">
      &lt;div class="level-left">
        &lt;slot name="bottom-left"/>
      &lt;/div>

      &lt;div class="level-right">
        &lt;div 
          v-if="paginated" 
          class="level-item">
          &lt;b-pagination
            :icon-pack="iconPack"
            :total="newDataTotal"
            :per-page="perPage"
            :simple="paginationSimple"
            :size="paginationSize"
            :current="newCurrentPage"
            @change="pageChanged"/>
        &lt;/div>
      &lt;/div>
    &lt;/div>
  &lt;/div>
&lt;/template>

&lt;script>
import { getValueByPath, indexOf } from '../../utils/helpers'

import Checkbox from '../checkbox/Checkbox'
import Icon from '../icon/Icon'
import Pagination from '../pagination/Pagination'

import TableMobileSort from './TableMobileSort'
import TableColumn from './TableColumn'

import BaseElementMixin from '../../utils/BaseElementMixin'

export default {
  name: 'BTable',
  components: {
    [Checkbox.name]: Checkbox,
    [Icon.name]: Icon,
    [Pagination.name]: Pagination,
    [TableMobileSort.name]: TableMobileSort,
    [TableColumn.name]: TableColumn,
  },
  mixins: [BaseElementMixin],
  props: {
    data: {
      type: Array,
      default: () => [],
    },
    columns: {
      type: Array,
      default: () => [],
    },
    bordered: Boolean,
    striped: Boolean,
    narrowed: Boolean,
    hoverable: Boolean,
    loading: Boolean,
    detailed: Boolean,
    checkable: Boolean,
    selected: Object,
    focusable: Boolean,
    customIsChecked: Function,
    isRowCheckable: {
      type: Function,
      default: () => true,
    },
    checkedRows: {
      type: Array,
      default: () => [],
    },
    mobileCards: {
      type: Boolean,
      default: true,
    },
    defaultSort: [String, Array],
    defaultSortDirection: {
      type: String,
      default: 'asc',
    },
    paginated: Boolean,
    currentPage: {
      type: Number,
      default: 1,
    },
    perPage: {
      type: [Number, String],
      default: 20,
    },
    paginationSimple: Boolean,
    paginationSize: String,
    backendSorting: Boolean,
    rowClass: {
      type: Function,
      default: () => '',
    },
    openedDetailed: {
      type: Array,
      default: () => [],
    },
    hasDetailedVisible: {
      type: Function,
      default: () => true,
    },
    detailKey: {
      type: String,
      default: '',
    },
    backendPagination: Boolean,
    total: {
      type: [Number, String],
      default: 0,
    },
  },
  data() {
    return {
      getValueByPath,
      newColumns: [...this.columns],
      visibleDetailRows: this.openedDetailed,
      newData: this.data,
      newDataTotal: this.backendPagination ? this.total : this.data.length,
      newCheckedRows: [...this.checkedRows],
      newCurrentPage: this.currentPage,
      currentSortColumn: {},
      isAsc: true,
      firstTimeSort: true, // Used by first time initSort
      _isTable: true, // Used by TableColumn
    }
  },
  computed: {
    tableClasses() {
      return {
        'is-bordered': this.bordered,
        'is-striped': this.striped,
        'is-narrow': this.narrowed,
        'has-mobile-cards': this.mobileCards,
        'is-hoverable':
          (this.hoverable || this.focusable) &amp;&amp; this.visibleData.length,
      }
    },

    /**
     * Splitted data based on the pagination.
     */
    visibleData() {
      if (!this.paginated) return this.newData

      const currentPage = this.newCurrentPage
      const perPage = this.perPage

      if (this.newData.length &lt;= perPage) {
        return this.newData
      } else {
        const start = (currentPage - 1) * perPage
        const end = parseInt(start, 10) + parseInt(perPage, 10)
        return this.newData.slice(start, end)
      }
    },

    /**
     * Check if all rows in the page are checked.
     */
    isAllChecked() {
      const validVisibleData = this.visibleData.filter(row =>
        this.isRowCheckable(row)
      )
      if (validVisibleData.length === 0) return false
      const isAllChecked = validVisibleData.some(currentVisibleRow => {
        return (
          indexOf(
            this.newCheckedRows,
            currentVisibleRow,
            this.customIsChecked
          ) &lt; 0
        )
      })
      return !isAllChecked
    },

    /**
     * Check if all rows in the page are checkable.
     */
    isAllUncheckable() {
      const validVisibleData = this.visibleData.filter(row =>
        this.isRowCheckable(row)
      )
      return validVisibleData.length === 0
    },

    /**
     * Check if has any sortable column.
     */
    hasSortablenewColumns() {
      return this.newColumns.some(column => {
        return column.sortable
      })
    },

    /**
     * Return total column count based if it's checkable or expanded
     */
    columnCount() {
      let count = this.newColumns.length
      count += this.checkable ? 1 : 0
      count += this.detailed ? 1 : 0

      return count
    },
  },
  watch: {
    /**
     * When data prop change:
     *   1. Update internal value.
     *   2. Reset newColumns (thead), in case it's on a v-for loop.
     *   3. Sort again if it's not backend-sort.
     *   4. Set new total if it's not backend-paginated.
     */
    data(value) {
      // Save newColumns before resetting
      const newColumns = this.newColumns

      this.newColumns = []
      this.newData = value

      // Prevent table from being headless, data could change and created hook
      // on column might not trigger
      this.$nextTick(() => {
        if (!this.newColumns.length) this.newColumns = newColumns
      })

      if (!this.backendSorting) {
        this.sort(this.currentSortColumn, true)
      }
      if (!this.backendPagination) {
        this.newDataTotal = value.length
      }
    },

    /**
     * When Pagination total change, update internal total
     * only if it's backend-paginated.
     */
    total(newTotal) {
      if (!this.backendPagination) return

      this.newDataTotal = newTotal
    },

    /**
     * When checkedRows prop change, update internal value without
     * mutating original data.
     */
    checkedRows(rows) {
      this.newCheckedRows = [...rows]
    },

    columns(value) {
      this.newColumns = [...value]
    },

    /**
     * When newColumns change, call initSort only first time (For example async data).
     */
    newColumns(newColumns) {
      if (newColumns.length &amp;&amp; this.firstTimeSort) {
        this.initSort()
        this.firstTimeSort = false
      } else if (newColumns.length) {
        if (this.currentSortColumn.field) {
          for (let i = 0; i &lt; newColumns.length; i++) {
            if (newColumns[i].field === this.currentSortColumn.field) {
              this.currentSortColumn = newColumns[i]
              break
            }
          }
        }
      }
    },

    /**
     * When the user wants to control the detailed rows via props.
     * Or wants to open the details of certain row with the router for example.
     */
    openedDetailed(expandedRows) {
      this.visibleDetailRows = expandedRows
    },

    currentPage(newVal) {
      this.newCurrentPage = newVal
    },
  },

  mounted() {
    this.checkPredefinedDetailedRows()
  },
  methods: {
    /**
     * Sort an array by key without mutating original data.
     * Call the user sort function if it was passed.
     */
    sortBy(array, key, fn, isAsc) {
      let sorted = []
      // Sorting without mutating original data
      if (fn &amp;&amp; typeof fn === 'function') {
        sorted = [...array].sort((a, b) => fn(a, b, isAsc))
      } else {
        sorted = [...array].sort((a, b) => {
          // Get nested values from objects
          let newA = getValueByPath(a, key)
          let newB = getValueByPath(b, key)

          if (!newA &amp;&amp; newA !== 0) return 1
          if (!newB &amp;&amp; newB !== 0) return -1
          if (newA === newB) return 0

          newA = typeof newA === 'string' ? newA.toUpperCase() : newA
          newB = typeof newB === 'string' ? newB.toUpperCase() : newB

          return isAsc ? (newA > newB ? 1 : -1) : newA > newB ? -1 : 1
        })
      }

      return sorted
    },

    /**
     * Sort the column.
     * Toggle current direction on column if it's sortable
     * and not just updating the prop.
     */
    sort(column, updatingData = false) {
      if (!column || !column.sortable) return

      if (!updatingData) {
        this.isAsc =
          column === this.currentSortColumn
            ? !this.isAsc
            : this.defaultSortDirection.toLowerCase() !== 'desc'
      }
      if (!this.firstTimeSort) {
        this.$emit('sort', column.field, this.isAsc ? 'asc' : 'desc')
      }
      if (!this.backendSorting) {
        this.newData = this.sortBy(
          this.newData,
          column.field,
          column.customSort,
          this.isAsc
        )
      }
      this.currentSortColumn = column
    },

    /**
     * Check if the row is checked (is added to the array).
     */
    isRowChecked(row) {
      return indexOf(this.newCheckedRows, row, this.customIsChecked) >= 0
    },

    /**
     * Remove a checked row from the array.
     */
    removeCheckedRow(row) {
      const index = indexOf(this.newCheckedRows, row, this.customIsChecked)
      if (index >= 0) {
        this.newCheckedRows.splice(index, 1)
      }
    },

    /**
     * Header checkbox click listener.
     * Add or remove all rows in current page.
     */
    checkAll() {
      const isAllChecked = this.isAllChecked
      this.visibleData.forEach(currentRow => {
        this.removeCheckedRow(currentRow)
        if (!isAllChecked) {
          if (this.isRowCheckable(currentRow)) {
            this.newCheckedRows.push(currentRow)
          }
        }
      })

      this.$emit('check', this.newCheckedRows)
      this.$emit('check-all', this.newCheckedRows)

      // Emit checked rows to update user variable
      this.$emit('update:checkedRows', this.newCheckedRows)
    },

    /**
     * Row checkbox click listener.
     * Add or remove a single row.
     */
    checkRow(row) {
      if (!this.isRowChecked(row)) {
        this.newCheckedRows.push(row)
      } else {
        this.removeCheckedRow(row)
      }

      this.$emit('check', this.newCheckedRows, row)

      // Emit checked rows to update user variable
      this.$emit('update:checkedRows', this.newCheckedRows)
    },

    /**
     * Row click listener.
     * Emit all necessary events.
     */
    selectRow(row, index) {
      this.$emit('click', row)

      if (this.selected === row) return

      // Emit new and old row
      this.$emit('select', row, this.selected)

      // Emit new row to update user variable
      this.$emit('update:selected', row)
    },

    /**
     * Paginator change listener.
     */
    pageChanged(page) {
      this.newCurrentPage = page > 0 ? page : 1
      this.$emit('page-change', this.newCurrentPage)
      this.$emit('update:currentPage', this.newCurrentPage)
    },

    /**
     * Toggle to show/hide details slot
     */
    toggleDetails(obj) {
      const found = this.isVisibleDetailRow(obj)

      if (found) {
        this.closeDetailRow(obj)
        this.$emit('details-close', obj)
      } else {
        this.openDetailRow(obj)
        this.$emit('details-open', obj)
      }

      // Syncs the detailed rows with the parent component
      this.$emit('update:openedDetailed', this.visibleDetailRows)
    },

    openDetailRow(obj) {
      const index = this.handleDetailKey(obj)
      this.visibleDetailRows.push(index)
    },

    closeDetailRow(obj) {
      const index = this.handleDetailKey(obj)
      const i = this.visibleDetailRows.indexOf(index)
      this.visibleDetailRows.splice(i, 1)
    },

    isVisibleDetailRow(obj) {
      const index = this.handleDetailKey(obj)
      const result = this.visibleDetailRows.indexOf(index) >= 0
      return result
    },

    /**
     * When the detailKey is defined we use the object[detailKey] as index.
     * If not, use the object reference by default.
     */
    handleDetailKey(index) {
      const key = this.detailKey
      return !key.length ? index : index[key]
    },

    checkPredefinedDetailedRows() {
      const defaultExpandedRowsDefined = this.openedDetailed.length > 0
      if (defaultExpandedRowsDefined &amp;&amp; !this.detailKey.length) {
        throw new Error(
          'If you set a predefined opened-detailed, you must provide an unique key using the prop "detail-key"'
        )
      }
    },

    /**
     * Check if footer slot has custom content.
     */
    hasCustomFooterSlot() {
      if (this.$slots.footer.length > 1) return true

      const tag = this.$slots.footer[0].tag
      if (tag !== 'th' &amp;&amp; tag !== 'td') return false

      return true
    },

    /**
     * Check if bottom-left slot exists.
     */
    hasBottomLeftSlot() {
      return typeof this.$slots['bottom-left'] !== 'undefined'
    },

    /**
     * Table arrow keys listener, change selection.
     */
    pressedArrow(pos) {
      if (!this.visibleData.length) return

      let index = this.visibleData.indexOf(this.selected) + pos

      // Prevent from going up from first and down from last
      index =
        index &lt; 0
          ? 0
          : index > this.visibleData.length - 1
            ? this.visibleData.length - 1
            : index

      this.selectRow(this.visibleData[index])
    },

    /**
     * Focus table element if has selected prop.
     */
    focus() {
      if (!this.focusable) return

      this.$el.querySelector('table').focus()
    },

    /**
     * Initial sorted column based on the default-sort prop.
     */
    initSort() {
      if (!this.defaultSort) return

      let sortField = ''
      let sortDirection = this.defaultSortDirection

      if (Array.isArray(this.defaultSort)) {
        sortField = this.defaultSort[0]
        if (this.defaultSort[1]) {
          sortDirection = this.defaultSort[1]
        }
      } else {
        sortField = this.defaultSort
      }

      this.newColumns.forEach(column => {
        if (column.field === sortField) {
          this.isAsc = sortDirection.toLowerCase() !== 'desc'
          this.sort(column, true)
        }
      })
    },
  },
}
&lt;/script>
</code></pre>
        </article>
    </section>




</div>

<footer>
    <img class="logo" src="http://nhnent.github.io/tui.component.tree/latest/styles/logo.png" style="width: 150px; height: 13px">
    <div class="footer-text">My awesome footer text</div>
</footer>
<script>prettyPrint();</script>
<script src="scripts/jquery.min.js"></script>
<script src="scripts/tui-doc.js"></script>
<script src="scripts/linenumber.js"></script>

    <script>
        var id = '_sub'.replace(/"/g, '_');
        var selectedApi = document.getElementById(id); // do not use jquery selector
        var $selectedApi = $(selectedApi);

        $selectedApi.removeClass('hidden');
        $selectedApi.parent().find('.glyphicon').removeClass('glyphicon-plus').addClass('glyphicon-minus');
        showLnbApi();
    </script>

</body>
</html>
